from collections import defaultdict
import logging
from statistics import median

from multiqc.base_module import BaseMultiqcModule, ModuleNoSamplesFound
from multiqc.plots import bargraph
from multiqc.utils import mqc_colour

log = logging.getLogger(__name__)

GROUP_TO_FEATURE = {
    "psm_file_combined": [
        "MS:1002255",
        "MS:1002252",
        "COMET:deltaCn",
        "COMET:lnNumSP",
        "COMET:lnRankSP",
        "COMET:IonFrac",
        "COMET:deltaLCn",
        "COMET:lnExpect",
        "charge1",
        "mass",
        "enzC",
        "charge5",
        "charge2",
        "absdm",
        "peplen",
        "charge4",
        "enzN",
        "charge3",
        "m0",
        "enzInt",
        "isotope_error",
        "dm",
        "COMET:lnNumSP",
        "charge1",
        "mass",
        "enzC",
        "COMET:lnRankSP",
        "charge5",
        "charge2",
        "absdm",
        "COMET:IonFrac",
        "COMET:deltaLCn",
        "peplen",
        "charge4",
        "enzN",
        "charge3",
        "m0",
        "COMET:lnExpect",
        "enzInt",
        "isotope_error",
        "dm",
    ],
    "ms2pip": [
        "ionb_min_abs_diff",
        "ionb_mse",
        "iony_std_abs_diff_norm",
        "ionb_mse_norm",
        "ionb_std_abs_diff_norm",
        "dotprod",
        "cos_norm",
        "iony_std_abs_diff",
        "iony_mean_abs_diff_norm",
        "dotprod_norm",
        "abs_diff_Q2_norm",
        "iony_spearman",
        "ionb_min_abs_diff_norm",
        "iony_max_abs_diff_norm",
        "dotprod_iony_norm",
        "ionb_abs_diff_Q2",
        "max_abs_diff",
        "dotprod_ionb_norm",
        "abs_diff_Q3_norm",
        "iony_min_abs_diff_norm",
        "cos_iony_norm",
        "spec_pearson",
        "std_abs_diff",
        "min_abs_diff_norm",
        "ionb_max_abs_diff",
        "dotprod_iony",
        "ionb_mean_abs_diff_norm",
        "max_abs_diff_iontype",
        "mean_abs_diff",
        "iony_max_abs_diff",
        "cos_iony",
        "ionb_std_abs_diff",
        "iony_pearson",
        "ionb_max_abs_diff_norm",
        "mean_abs_diff_norm",
        "abs_diff_Q1",
        "ionb_pearson_norm",
        "ionb_abs_diff_Q1_norm",
        "min_abs_diff",
        "ionb_mean_abs_diff",
        "spec_spearman",
        "iony_mean_abs_diff",
        "abs_diff_Q1_norm",
        "iony_min_abs_diff",
        "ionb_spearman",
        "iony_abs_diff_Q3_norm",
        "min_abs_diff_iontype",
        "cos_ionb_norm",
        "abs_diff_Q2",
        "abs_diff_Q3",
        "spec_pearson_norm",
        "ionb_abs_diff_Q2_norm",
        "std_abs_diff_norm",
        "dotprod_ionb",
        "cos_ionb",
        "ionb_abs_diff_Q3",
        "iony_mse_norm",
        "iony_pearson_norm",
        "spec_mse_norm",
        "ionb_abs_diff_Q3_norm",
        "iony_abs_diff_Q1_norm",
        "ionb_pearson",
        "max_abs_diff_norm",
        "spec_mse",
        "iony_mse",
        "ionb_abs_diff_Q1",
        "iony_abs_diff_Q2_norm",
        "iony_abs_diff_Q1",
        "iony_abs_diff_Q3",
        "cos",
        "iony_abs_diff_Q2",
    ],
    "deeplc": [
        "rt_diff",
        "predicted_retention_time",
        "predicted_retention_time_best",
        "observed_retention_time_best",
        "rt_diff_best",
        "observed_retention_time",
    ],
}

FEATURE_TO_GROUP = {feature: group for group, features in GROUP_TO_FEATURE.items() for feature in features}

GROUP_NAME = {
    "psm_file_combined": "PSM File",
    "ms2pip": "MS2PIP",
    "deeplc": "DeepLC",
}


class MultiqcModule(BaseMultiqcModule):
    """
    The module parses results generated by [Percolator](https://github.com/percolator/percolator),
    a semi-supervised learning framework for peptide identification from shotgun proteomics datasets.
    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="Percolator",
            anchor="percolator",
            href="https://github.com/percolator/percolator",
            info="Semi-supervised learning for peptide identification from shotgun proteomics datasets.",
            doi="10.1007/s13361-016-1460-7",
        )

        # Parse logs
        self.data_by_sample = dict()
        for f in self.find_log_files("percolator", filehandles=True):
            self.parse_percolator(f)

        # Filter to strip out ignored sample names
        self.data_by_sample = self.ignore_samples(self.data_by_sample)

        if len(self.data_by_sample) == 0:
            raise ModuleNoSamplesFound
        log.info(f"Found {len(self.data_by_sample)} logs")

        # Superfluous function call to confirm that it is used in this module
        # Replace None with an actual version if it is available
        self.add_software_version(None)

        # Summarize the data from all samples by computing the median across all samples for each feature
        values_by_feature = defaultdict(list)
        for sample_dict in self.data_by_sample.values():
            for feature, value in sample_dict.items():
                values_by_feature[feature].extend(value)
        # Since our bars are features and not samples, computing the median of each feature across samples
        median_weights_by_feature = dict()
        for feature, values in values_by_feature.items():
            median_value = median(values)
            median_weights_by_feature[feature] = median_value
        # Sort the features by the median weight
        median_weights_by_feature = dict(sorted(median_weights_by_feature.items(), key=lambda x: -x[1], reverse=True))
        barplot_data = {
            feature: {f"{GROUP_NAME[FEATURE_TO_GROUP[feature]]}": median_value}
            for feature, median_value in median_weights_by_feature.items()
        }

        """Plot the bar plot of the median weight for each feature."""
        self.add_section(
            anchor="percolator_median_feature_weights",
            helptext="""The bar plot illustrates the median weights for each feature, 
        which have been assigned to one of three categories: psm_file_combined, ms2pip and deeplc.""",
            description="""For each feature, the associated weight is the median value calculated over all input samples.""",
            plot=bargraph.plot(
                barplot_data,
                # cats=cats,
                pconfig={
                    "id": "percolator_plot",
                    "title": "Percolator: Median Feature Weights",
                    "sort_samples": False,
                    "hide_zero_cats": False,
                },
            ),
        )

        self.write_data_file(self.data_by_sample, "multiqc_percolator_barplot")

    def parse_percolator(self, file):
        """Extract the normalized weights for each feature from the percolator logs."""
        s_name = file["s_name"]
        lines = file["f"].readlines()
        header = lines[0].strip().split("\t")
        if s_name in self.data_by_sample:
            log.debug(f"Duplicate sample name found! Overwriting: {s_name}")
        self.data_by_sample[s_name] = {feature: list() for feature in header}
        # Select every third line starting from the first data line after the header (normalized values)
        for i in range(1, len(lines), 3):
            line = lines[i].strip().split("\t")
            # Take the absolute value of each element
            line = [float(x) for x in line]
            assert len(line) == len(header)
            # For each sample, collect all values for each feature in a list
            for elem in range(len(line)):
                self.data_by_sample[s_name][header[elem]].append(line[elem])
        self.add_data_source(file, s_name)
