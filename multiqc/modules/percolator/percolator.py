import logging
from statistics import median

from multiqc.base_module import BaseMultiqcModule, ModuleNoSamplesFound
from multiqc.plots import bargraph

log = logging.getLogger(__name__)

feature_name_dict = {
    "psm_file_combined": [
        "MS:1002255",
        "MS:1002252",
        "COMET:deltaCn",
        "COMET:lnNumSP",
        "COMET:lnRankSP",
        "COMET:IonFrac",
        "COMET:deltaLCn",
        "COMET:lnExpect",
        "charge1",
        "mass",
        "enzC",
        "charge5",
        "charge2",
        "absdm",
        "peplen",
        "charge4",
        "enzN",
        "charge3",
        "m0",
        "enzInt",
        "isotope_error",
        "dm",
        "COMET:lnNumSP",
        "charge1",
        "mass",
        "enzC",
        "COMET:lnRankSP",
        "charge5",
        "charge2",
        "absdm",
        "COMET:IonFrac",
        "COMET:deltaLCn",
        "peplen",
        "charge4",
        "enzN",
        "charge3",
        "m0",
        "COMET:lnExpect",
        "enzInt",
        "isotope_error",
        "dm",
    ],
    "ms2pip": [
        "ionb_min_abs_diff",
        "ionb_mse",
        "iony_std_abs_diff_norm",
        "ionb_mse_norm",
        "ionb_std_abs_diff_norm",
        "dotprod",
        "cos_norm",
        "iony_std_abs_diff",
        "iony_mean_abs_diff_norm",
        "dotprod_norm",
        "abs_diff_Q2_norm",
        "iony_spearman",
        "ionb_min_abs_diff_norm",
        "iony_max_abs_diff_norm",
        "dotprod_iony_norm",
        "ionb_abs_diff_Q2",
        "max_abs_diff",
        "dotprod_ionb_norm",
        "abs_diff_Q3_norm",
        "iony_min_abs_diff_norm",
        "cos_iony_norm",
        "spec_pearson",
        "std_abs_diff",
        "min_abs_diff_norm",
        "ionb_max_abs_diff",
        "dotprod_iony",
        "ionb_mean_abs_diff_norm",
        "max_abs_diff_iontype",
        "mean_abs_diff",
        "iony_max_abs_diff",
        "cos_iony",
        "ionb_std_abs_diff",
        "iony_pearson",
        "ionb_max_abs_diff_norm",
        "mean_abs_diff_norm",
        "abs_diff_Q1",
        "ionb_pearson_norm",
        "ionb_abs_diff_Q1_norm",
        "min_abs_diff",
        "ionb_mean_abs_diff",
        "spec_spearman",
        "iony_mean_abs_diff",
        "abs_diff_Q1_norm",
        "iony_min_abs_diff",
        "ionb_spearman",
        "iony_abs_diff_Q3_norm",
        "min_abs_diff_iontype",
        "cos_ionb_norm",
        "abs_diff_Q2",
        "abs_diff_Q3",
        "spec_pearson_norm",
        "ionb_abs_diff_Q2_norm",
        "std_abs_diff_norm",
        "dotprod_ionb",
        "cos_ionb",
        "ionb_abs_diff_Q3",
        "iony_mse_norm",
        "iony_pearson_norm",
        "spec_mse_norm",
        "ionb_abs_diff_Q3_norm",
        "iony_abs_diff_Q1_norm",
        "ionb_pearson",
        "max_abs_diff_norm",
        "spec_mse",
        "iony_mse",
        "ionb_abs_diff_Q1",
        "iony_abs_diff_Q2_norm",
        "iony_abs_diff_Q1",
        "iony_abs_diff_Q3",
        "cos",
        "iony_abs_diff_Q2",
    ],
    "deeplc": [
        "rt_diff",
        "predicted_retention_time",
        "predicted_retention_time_best",
        "observed_retention_time_best",
        "rt_diff_best",
        "observed_retention_time",
    ],
}


class MultiqcModule(BaseMultiqcModule):
    """
    The module parses results generated by [Percolator](https://github.com/percolator/percolator),
    a semi-supervised learning framework for peptide identification from shotgun proteomics datasets.
    """

    def __init__(self):
        super(MultiqcModule, self).__init__(
            name="Percolator",
            anchor="percolator",
            href="https://github.com/percolator/percolator",
            info="Semi-supervised learning for peptide identification from shotgun proteomics datasets.",
        )

        # Parse logs
        self.percolator = dict()
        for f in self.find_log_files("percolator", filehandles=True):
            self.parse_percolator(f)

        # Filter to strip out ignored sample names
        self.percolator = self.ignore_samples(self.percolator)

        if len(self.percolator) == 0:
            raise ModuleNoSamplesFound
        log.info(f"Found {len(self.percolator)} logs")
        self.write_data_file(self.percolator, "multiqc_percolator_full")

        # Summarize the data from all samples by computing the median across all samples for each feature
        self.summarized_data = {group: dict() for group in feature_name_dict.keys()}
        self.compute_median()
        self.write_data_file(self.summarized_data, "multiqc_percolator_summarized")

        # Superfluous function call to confirm that it is used in this module
        # Replace None with an actual version if it is available
        self.add_software_version(None)

        descr_plot = """The bar plot illustrates the median weights for each feature, 
        which have been assigned to one of three categories: psm_file_combined, ms2pip and deeplc."""
        helptext = """For each feature, the associated weight is the median value calculated over all input samples. 
        Prior to computing the median, the absolute value was calculated, 
        as only the magnitude is of interest in this context."""
        self.add_section(
            plot=self.percolator_barplot(), helptext=helptext, description=descr_plot
        )

    def parse_percolator(self, file):
        """Extract the normalized weights for each feature from the percolator logs."""
        s_name = file["s_name"]
        lines = file["f"].readlines()
        header = lines[0].strip().split("\t")
        if s_name in self.percolator:
            log.debug(f"Duplicate sample name found! Overwriting: {s_name}")
        self.percolator[s_name] = {feature: list() for feature in header}
        # Select every third line starting from the first data line after the header (normalized values)
        for i in range(1, len(lines), 3):
            line = lines[i].strip().split("\t")
            # Take the absolute value of each element
            line = [abs(float(x)) for x in line]
            assert len(line) == len(header)
            # For each sample, collect all values for each feature in a list
            for elem in range(len(line)):
                self.percolator[s_name][header[elem]].append(line[elem])
        self.add_data_source(file, s_name)

    def compute_median(self):
        """Compute the median weight for each feature across all samples."""
        # Collect the values for each feature across all samples
        for sample_dict in self.percolator.values():
            for feature, value in sample_dict.items():
                group = [
                    group
                    for group, features in feature_name_dict.items()
                    if feature in features
                ]
                assert len(group) == 1
                group = group[0]
                if feature not in self.summarized_data[group]:
                    self.summarized_data[group][feature] = list()
                self.summarized_data[group][feature].extend(value)
        # Compute the median for each feature
        for group in self.summarized_data.keys():
            for feature, values in self.summarized_data[group].items():
                median_value = median(values)
                self.summarized_data[group][feature] = median_value

    def percolator_barplot(self):
        """Plot the bar plot of the median weight for each feature."""
        plot_config = {
            "id": "percolator_plot",
            "title": "Percolator: Median Feature Weights",
        }

        return bargraph.plot(self.summarized_data, pconfig=plot_config)
